#!/usr/bin/env bash
set -eo pipefail; [[ $DOKKU_TRACE ]] && set -x
source "$PLUGIN_CORE_AVAILABLE_PATH/common/functions"
source "$PLUGIN_CORE_AVAILABLE_PATH/config/functions"
source "$PLUGIN_CORE_AVAILABLE_PATH/common/property-functions"

fn-strip-ports() {
  declare DEPLOYMENT_FILE="$1"
  local TMP_FILE=$(mktemp "/tmp/${FUNCNAME[0]}.XXXX")

  jq -M 'del(.spec.template.spec.containers[0].ports)' < "$DEPLOYMENT_FILE" > "$TMP_FILE"
  mv "$TMP_FILE" "$DEPLOYMENT_FILE"
}

fn-set-env-vars() {
  declare APP="$1" DEPLOYMENT_FILE="$2"
  local TMP_FILE=$(mktemp "/tmp/${FUNCNAME[0]}.XXXX")
  local TMP_FILE_TWO=$(mktemp "/tmp/${FUNCNAME[0]}.XXXX")
  trap 'rm -rf "$TMP_FILE" > /dev/null' RETURN INT TERM EXIT
  trap 'rm -rf "$TMP_FILE_TWO" > /dev/null' RETURN INT TERM EXIT
  local key JSON_KEY JSON_VALUE

  cat "$DEPLOYMENT_FILE" > "$TMP_FILE"
  # TODO: Implement `dokku config:json` and use that to populate containers.env
  while read -r key; do
    JSON_KEY="$key" JSON_VALUE="$(dokku config:get "$APP" "$key")" jq -M ".spec.template.spec.containers[0].env += [{\"name\": env.JSON_KEY, \"value\": env.JSON_VALUE}]" < "$TMP_FILE" > "$TMP_FILE_TWO"
    mv "$TMP_FILE_TWO" "$TMP_FILE"
  done < <(dokku config:keys "$APP")
  mv "$TMP_FILE" "$DEPLOYMENT_FILE"
}

scheduler-kubernetes-scheduler-deploy() {
  declare desc="deploys an image tag for a given application"
  declare trigger="scheduler-kubernetes scheduler-deploy"
  declare DOKKU_SCHEDULER="$1" APP="$2" IMAGE_TAG="$3"
  local DEPLOYMENT_TEMPLATE="$PLUGIN_AVAILABLE_PATH/scheduler-kubernetes/templates/deployment.json.sigil"
  local SERVICE_TEMPLATE="$PLUGIN_AVAILABLE_PATH/scheduler-kubernetes/templates/deployment.json.sigil"

  if [[ "$DOKKU_SCHEDULER" != "kubernetes" ]]; then
    return
  fi

  local line PROC_TYPE PROC_COUNT CONTAINER_INDEX
  local DOKKU_SCALE_FILE="$DOKKU_ROOT/$APP/DOKKU_SCALE"
  local DEPLOYMENT_ID="$(date +%s)"
  local TMP_FILE=$(mktemp "/tmp/${FUNCNAME[0]}.XXXX")
  trap 'rm -rf "$TMP_FILE" > /dev/null' RETURN INT TERM EXIT

  dokku_log_info2 "Deploying via kubernetes"
  IMAGE=$(get_deploying_app_image_name "$APP" "$IMAGE_TAG")
  plugn trigger pre-deploy "$APP" "$IMAGE_TAG"

  while read -r line || [[ -n "$line" ]]; do
    [[ "$line" =~ ^#.* ]] && continue
    line="$(strip_inline_comments "$line")"
    PROC_TYPE=${line%%=*}
    PROC_COUNT=${line#*=}

    dokku_log_info1 "Deploying ${PROC_TYPE} to ${PROC_COUNT}"
    RESOURCE_REQUESTS_CPU=$(plugn trigger resource-get-property "$APP" "$PROC_TYPE" "reserve" "cpu" || echo "100m")
    RESOURCE_REQUESTS_MEMORY=$(plugn trigger resource-get-property "$APP" "$PROC_TYPE" "limit" "memory" || echo "256Mi")
    RESOURCE_LIMITS_CPU=$(plugn trigger resource-get-property "$APP" "$PROC_TYPE" "limit" "cpu" || echo "100m")
    RESOURCE_LIMITS_MEMORY=$(plugn trigger resource-get-property "$APP" "$PROC_TYPE" "limit" "memory" || echo "256Mi")

    SIGIL_PARAMS=(APP="$APP"
        RESOURCE_REQUESTS_CPU="$RESOURCE_REQUESTS_CPU" RESOURCE_REQUESTS_MEMORY="$RESOURCE_REQUESTS_MEMORY"
        RESOURCE_LIMITS_CPU="$RESOURCE_LIMITS_CPU" RESOURCE_LIMITS_MEMORY="$RESOURCE_LIMITS_MEMORY"
        IMAGE="$IMAGE"
        REPLICAS="$PROC_COUNT" PROCESS_TYPE="$PROC_TYPE" PORT="5000")

    sigil -f "$DEPLOYMENT_TEMPLATE" "${SIGIL_PARAMS[@]}" | cat -s > $TMP_FILE
    [[ "$PROC_TYPE" != "web" ]] && fn-strip-ports "$TMP_FILE"
    fn-set-env-vars "$TMP_FILE"

    kubectl apply -f "$TMP_FILE" | sed "s/^/       /"
    "${DOKKU_LIB_ROOT}/data/scheduler-kubernetes/kubedog" rollout track deployment "${APP}-${PROCESS_TYPE}" | sed "s/^/       /"

    if [[ "$PROC_TYPE" == "web" ]]; then
      sigil -f "$SERVICE_TEMPLATE" "${SIGIL_PARAMS[@]}" | cat -s > $TMP_FILE
      kubectl apply -f "$TMP_FILE" | sed "s/^/       /"
      "${DOKKU_LIB_ROOT}/data/scheduler-kubernetes/kubedog" rollout track service "${APP}-${PROCESS_TYPE}" | sed "s/^/       /"
    fi
  done < "$DOKKU_SCALE_FILE"

  dokku_log_info2 "Deploy complete"

  dokku_log_info1 "Running post-deploy"
  plugn trigger core-post-deploy "$APP" "" "" "$IMAGE_TAG"
  plugn trigger post-deploy "$APP" "" "" "$IMAGE_TAG"
}

scheduler-kubernetes-scheduler-deploy "$@"
